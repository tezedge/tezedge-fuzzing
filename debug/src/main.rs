use crypto::crypto_box::{PrecomputedKey, PublicKey, SecretKey};
use crypto::hash::HashType;
use storage::operations_storage::OperationKey;
use storage::persistent::Decoder;
use storage::BlockHeaderWithHash;
use tezos_messages::p2p::binary_message::BinaryMessage;
use tezos_messages::p2p::encoding::prelude::AckMessage;
use tezos_messages::p2p::encoding::prelude::OperationHashesForBlocksMessage;

use std::env;
use std::fs::File;
use std::io;
use std::io::Read;

fn operation_hashes_for_blocks_message_stack_overflow2() -> Result<(), &'static str> {
    let data = [
        0x72, 0x62, 0x4c, 0x62, 0x2d, 0x4c, 0x62, 0x2d, 0xb8, 0xeb, 0x63, 0x45, 0x54, 0x3b, 0xf0,
        0xf0, 0xf0, 0xef, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0,
    ];
    let _ = OperationHashesForBlocksMessage::from_bytes(&data);
    Ok(())
}

fn operation_hashes_for_blocks_message_stack_overflow(data: &[u8]) -> Result<(), &str> {
    let _ = OperationHashesForBlocksMessage::from_bytes(&data);
    Ok(())
}

fn ack_message_from_bytes(data: &[u8]) -> Result<(), &str> {
    let _ = AckMessage::from_bytes(&data);
    Ok(())
}

fn hashtype_blockHash_hash_to_b58check() {
    let _ = HashType::BlockHash.hash_to_b58check(&[0x64, 0x2b, 0x9b, 0x89, 0xf1, 0xdf]);
}

fn blockheaderwithhash_decode() {
    let _ = BlockHeaderWithHash::decode(&[0x24, 0x18, 0x5c, 0x6f, 0xcd]);
}

fn operationkey_decode() {
    let _ = OperationKey::decode(&[0xff, 0xff, 0x2a, 0x21]);
}

/* FIXED
use hex::FromHex;

fn cryptobox_precompute() {
    let pk = PublicKey::from_hex("").expect("should failed");
    let sk = SecretKey::from_hex("").expect("should failed");
    let pck = PrecomputedKey::precompute(&pk, &sk);
}
*/

fn base58_from_base58check_substract_overflow() {
    use crypto::base58::FromBase58Check;
    let s = "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111q55555555";
    let _ = s.from_base58check();
}

/* FIXED
fn nonce_get_bytes_panic() {
    use crypto::nonce::Nonce;

    let data = "rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr";
    let nonce = Nonce::new(data.as_bytes());
    nonce.increment();
    let out = nonce.get_bytes();
}
*/

/// Read the contents from file path
fn read_contents_from_path(path_str: &String) -> Result<Vec<u8>, io::Error> {
    let mut buffer: Vec<u8> = Vec::new();
    let file_path = std::path::PathBuf::from(path_str);
    println!("[+] file_to_process: {:?}", file_path);
    let mut file = File::open(file_path)?;
    file.read_to_end(&mut buffer)?;
    drop(file);
    Ok(buffer)
}

fn main() {
    println!("[+] Start debugging");
    let args: Vec<String> = env::args().collect();
    // verify file_to_process is provided
    if args.len() != 2 {
        println!("Usage: <file_to_process>\n");
        return;
    }

    operationkey_decode();

    // read data from provided file
    let data = read_contents_from_path(&args[1]).expect("[-] cannot read file content");
    // call the fuzzing target
    let _ = ack_message_from_bytes(&data); //(&data);
                                           //    .map_err(|e| println!("[-] error: {:?}", e));

    //base58_from_base58check_substract_overflow();

    operationkey_decode();
    println!("[+] No crash\n");
}
